# MPASM 架构指令集

## 1. 架构

MPASM 是为高级语言 MPC 设计的中间表示层，采用类似于汇编的形式表述。MPASM 是一种混杂式的语言，也就是说并不是严格的顺序执行。执行时存在两种模式：执行模式和解析模式。前者立即执行代码，后者分离代码并记录到一个特定的位置。

MPASM 是栈式的，也就是没有寄存器。参与运算的操作数和结构都存储在栈中，而变量存储在名为环境的位置。MPASM 追求顺序，于是函数调用时将每个参数从栈顶转移到临时的队列中，从而保证调用方和被调用方都参数有序。MPASM 是面向对象的，当然，类不是一个变量，而是存储在全局类表的一个特殊键值对。MPASM 全文不分段，所有内容并列存储。MPASM 也是指令无类型的，虽然类型会决定运算的方式，但是编译时无需考虑这一点，执行时才会处理。除非存在明显的语法错误，否则所有错误都在执行时被处理。

MPASM 为每一个 Scope 创建一个环境，嵌套继承父级 Scope，函数调用继承函数定义位置的 Scope。在 MPASM 表述中，Scope 是一个 `br` 指令到一个 `er` 指令的一段区间，它们分别负责创建和销毁 Scope。

MPASM 为稍远的需求设计，包含部分 MPC 暂时未使用的特性。

## 指令集

如无说明，如果操作数在栈中，以下运算均消耗操作数。

### 运算指令

- `a2i` 如果栈顶是 `Array` 则转换为 `Iterator`
- `adc` 将栈顶作为修饰函数修饰栈的第二项，保存到栈顶
- `add` 将栈顶和栈的第二项相加，保存到栈顶
- `adec` 栈顶自减并出栈，自减前的复制入栈
- `ainc` 栈顶自增并出栈，自增前的复制入栈
- `band` 将栈顶和栈的第二项按位与，保存到栈顶
- `bdec` 栈顶自减并出栈，自减后的复制入栈
- `binc` 栈顶自增并出栈，自增后的复制入栈
- `bnot` 栈顶按位取反
- `bor` 将栈顶和栈的第二项按位或，保存到栈顶
- `bxor` 将栈顶和栈的第二项按位异或，保存到栈顶
- `ceq` 比较栈顶和栈的第二项是否相等，保存到栈顶
- `cg` 比较栈的第二项是否比栈顶大，保存到栈顶
- `cge` 比较栈的第二项是否大于等于栈顶，保存到栈顶
- `cl` 比较栈的第二项是否比栈顶小，保存到栈顶
- `cle` 比较栈的第二项是否小于等于栈顶，保存到栈顶
- `cneq` 比较栈顶和栈的第二项是否不等，保存到栈顶
- `div` 计算栈的第二项除以栈顶，保存到栈顶
- `iend` 获取栈顶 `Iterator` 是否没有下一项且不消耗，保存到栈顶
- `if` 将栈顶转换为 `Boolean` 型
- `iget` 获取栈顶 `Iterator` 的值且不消耗，保存到栈顶
- `iinc` 栈顶 `Iterator` 取下一项
- `index` 获取栈的第二项的第栈顶项，保存到栈顶
- `jarr` 将栈的第二项 `Array` 添加栈顶的内容，保存到栈顶
- `mod` 计算栈的第二项模栈顶，保存到栈顶
- `mov` 将栈的第二项赋值为栈顶，保存复制到栈顶
- `mul` 计算栈顶乘栈的第二项，保存到栈顶
- `neg` 计算栈顶的负，保存到栈顶
- `not` 将栈顶逻辑非
- `pnul` 丢弃栈顶，不保存
- `pos` 计算栈顶的正，保存到栈顶
- `shl` 将栈的第二位左移栈顶位，保存到栈顶
- `shr` 将栈的第二位右移栈顶位，保存到栈顶
- `sub` 计算栈的第二项减栈顶，保存到栈顶

### 常量指令

- `cfl32 <payload>` 将指令附带的单精度浮点数加载到栈顶
- `cfl <payload>` 将指令附带的双精度浮点数加载到栈顶
- `cbyte <payload>` 将指令附带的字节加载到栈顶（无符号）
- `ci8 <payload>` 将指令附带的 8 位整数加载到栈顶（有符号）
- `ci16 <payload>` 将指令附带的 16 位整数加载到栈顶
- `ci32 <payload>` 将指令附带的 32 位整数加载到栈顶
- `cint <payload>` 将指令附带的 64 位整数加载到栈顶
- `cld <payload>` 将指令附带的对象加载到栈顶，只能是运行时创建，不可保存
- `cstr <payload>` 将指令附带的字符串加载到栈顶
- `err` 创造一个错误对象加载到栈顶
- `falsev` 将一个 `False` 加载到栈顶
- `mkarr` 创建一个空 `Array` 到栈顶
- `nullv` 将一个 `Null` 加载到栈顶
- `truev` 将一个 `True` 加载到栈顶

### 跳转和函数指令

- `arg` 将栈顶元素转移到当前参数队列
- `bfd` 从当前位置开始创建函数
- `call` 使用当前参数队列调用栈顶的函数，返回值保存到栈顶
- `clarg` 恢复上一个参数队列
- `earg` 将栈顶 `Array` 展开到参数队列
- `efd` 结束创建函数，将函数保存到栈顶
- `erecv <name>` 接受参数队列剩余全部并存入 `Array` 置于保存的变量
- `flag <id>` 建立一个用于跳转的标记，连接时被删除
- `jf <id>/<pos>` 如果栈顶条件不成立则跳转
- `jfk <id>/<pos>` 如果栈顶条件不成立则条件，保留栈顶的值
- `jmp <id>/<pos>` 无条件跳转到指令记录的位置
- `jt <id>/<pos>` 如果栈顶条件成立则跳转
- `jtk <id>/<pos>` 如果栈顶条件成立则跳转，保留栈顶的值
- `recv <name>` 接受参数队列首项到保存的变量
- `ret` 返回
- `srvl` 使用栈顶设置返回值
- `treq <number> <type>` 要求指定项参数类型
- `pcq` 备份当前参数队列并创建一个新的

### 面向对象指令

- `access <name>` 范围类成员、枚举项或反向调用
- `attr <super>` 设置接下来的类继承的类
- `bfdc` 从当前位置开始创建构造函数
- `bfdd` 从当前位置开始创建析构函数
- `class` 开始定义类
- `eclass <name>` 结束定义类并保存到指令存储的名称
- `efdc <args>` 结束定义构造函数并保存
- `efdd` 结束定义析构函数并保存
- `facs <name>` 无视访问控制强制访问类成员
- `final` 声明类成员函数是不可重写的
- `method <name>` 将栈顶存储为指定类成员函数
- `new <name>` 以当前参数队列创建指令携带的类的实例
- `priv` 声明接下来的类成员是私有的
- `pub` 声明接下来的类成员是公有的
- `static <name>` 将栈顶存储为类常量
- `value <name>` 将栈顶存储为类变量

### 枚举指令

- `enum` 开始创建一个枚举
- `eentry <name>` 使用指令保存的名称新开一项
- `eenum <name>` 结束创建枚举并保存到指令携带的名称

### 环境管理指令

- `br` 新开环境
- `cf` 清除定义变量参数
- `constv` 声明接下来定义的是常量
- `del <var>` 删除变量，按距离优先
- `er` 恢复上一个环境
- `global` 声明接下来定义的变量是全局的
- `let <var>` 在当前环境使用栈顶新建或重写变量
- `push` 将变量推入栈顶，按距离优先
- `var <var>` 在当前环境使用栈顶新建变量

### 系统和调试指令

- `eflag <id>` 使用栈顶设置运行时参数
- `eofv` 强制声明文件结尾
- `eval` 使用当前环境执行栈顶保存的代码
- `int <id>` 执行系统调用
- `line` 声明下一行
- `src <code>` 声明本行代码
- `sscl <id>` 设置系统调用号
- `throw` 使用栈顶元素抛出指定异常
- `trap` 断点，暂停执行

严重 - 待修复：break、continue、return 可能导致 br、er 失调
解决方案：在 ToAsmArgs 中统计 scope 深度，运行前疯狂 er
